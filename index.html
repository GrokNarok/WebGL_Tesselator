<html>

<head>
<title>Tessellator</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

    uniform vec3 uMaterialAmbientColor;
    uniform vec3 uMaterialDiffuseColor;
    uniform vec3 uMaterialSpecularColor;
    uniform float uMaterialShininess;

    uniform vec3 uAmbientLightingColor;

    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingDiffuseColor;
    uniform vec3 uPointLightingSpecularColor;

    uniform sampler2D uSampler;


    void main(void) {
        vec3 ambientLightWeighting = uAmbientLightingColor;
        
        vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
        vec3 normal = normalize(vTransformedNormal);
        
        vec3 eyeDirection = normalize(-vPosition.xyz);
        vec3 reflectionDirection = reflect(-lightDirection, normal);
        
        float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
        vec3 specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;
        
        float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);
        vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;
        
        float alpha = 1.0;
        gl_FragColor = vec4(
            uMaterialAmbientColor * ambientLightWeighting
            + uMaterialDiffuseColor * diffuseLightWeighting
            + uMaterialSpecularColor * specularLightWeighting,
            alpha
        );
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;
    
    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>


<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
    
    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }
        
        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }
        
        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }
        
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        
        return shader;
    }

    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");
        
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        gl.useProgram(shaderProgram);
        
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
        
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        
        shaderProgram.materialAmbientColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialAmbientColor");
        shaderProgram.materialDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialDiffuseColor");
        shaderProgram.materialSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialSpecularColor");
        shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
        shaderProgram.ambientLightingColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientLightingColor");
        shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
        shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
        shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
    }

    // Matrix helper code
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        
        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }
    // End matrix helper code

    // Code that handles camera rotation via mouse drag.
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;
    var cameraRotationMatrix = mat4.create();
    mat4.identity(cameraRotationMatrix);

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
        mouseDown = false;
        mat4.identity(cameraRotationMatrix);
    }

    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;
        
        var deltaX = newX - lastMouseX
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, deltaX / 200, [0, 1, 0]);
        
        var deltaY = newY - lastMouseY;
        mat4.rotate(newRotationMatrix, deltaY / 200, [1, 0, 0]);
        
        mat4.multiply(newRotationMatrix, cameraRotationMatrix, cameraRotationMatrix);
        
        lastMouseX = newX
        lastMouseY = newY;
    }
    // End camera rotation code

    // Basic object in a scene.
    function RenderableObject() {
        this.vertexPositionBuffer = gl.createBuffer();
        this.vertexNormalBuffer = gl.createBuffer();
        this.vertexIndexBuffer = gl.createBuffer();
        
        this.colour = [1.0, 1.0, 1.0];
        this.position = [0.0, 0.0, 0.0];
//      this.rotation = [0.0, 0.0, 0.0];
//      this.scale = 1.0;
        
        this.show = false;
    }
    
    // Draw function
    RenderableObject.prototype.draw = function () {
        if (!this.show) {
            return;
        }
        
        mvPushMatrix();
        
        mat4.translate(mvMatrix, this.position);
        
        gl.uniform3f(shaderProgram.materialAmbientColorUniform, this.colour[0], this.colour[1], this.colour[2]);
        gl.uniform3f(shaderProgram.materialDiffuseColorUniform, this.colour[0], this.colour[1], this.colour[2]);
        gl.uniform3f(shaderProgram.materialSpecularColorUniform, this.colour[0], this.colour[1], this.colour[2]);
        gl.uniform1f(shaderProgram.materialShininessUniform, 5);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, this.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, this.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        
        mvPopMatrix();
    };


    // An object that interpolates a value over time and sets it via a provided function.
    // setterCallback   The function that will be called with interpolated value as parameter.
    // startValue       Value to be set at the start of the timeline
    // endValue         Value to be set at the end of the timeline
    // duration         Amount of time (in milliseconds) in will take to go from startValue to endValue
    function InterpolationTimeline(setterCallback, startValue, endValue, duration) {
        if (duration == 0) {
            duration = 1; // hacky but we don't want to divide by zero
        }
        
        this.setterCallback = setterCallback;
        this.startValue = startValue;
        this.endValue = endValue;
        this.duration = duration;
        
        this.elapsedTime = 0;
        this.active = false;
    }
    
    InterpolationTimeline.prototype.frameMove = function (deltaTime) {
        if (this.active == false) {
            return;
        }
        
        if (!Array.isArray(this.startValue) && !Array.isArray(this.endValue)) {
            this.setterCallback((this.startValue * (1 - (this.elapsedTime / this.duration))) + (this.endValue * (this.elapsedTime / this.duration)));
        } else if (Array.isArray(this.startValue) && Array.isArray(this.endValue) && this.startValue.length == this.endValue.length) {
            var finalValue = [];
            var i;
            for(i = 0; i < this.startValue.length; i++) {
                finalValue[i] = (this.startValue[i] * (1 - (this.elapsedTime / this.duration))) + (this.endValue[i] * (this.elapsedTime / this.duration));
            }
            this.setterCallback(finalValue);
        }
        
        if (this.elapsedTime >= this.duration) {
            this.active = false;
        }
        this.elapsedTime += deltaTime;
        if (this.elapsedTime > this.duration) {
            this.elapsedTime = this.duration;
        }
    }


    // Calculates perpendicular vertex normals from geometry definition, triangle vertices need to be defines in clockwise order.
    function calculateNormals(rendObj, vertices, vertexIndices)
    {
        rendObj.vertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, rendObj.vertexNormalBuffer);
        var vertexNormals = new Float32Array(rendObj.vertexPositionBuffer.numItems * rendObj.vertexPositionBuffer.itemSize);
        for (var i = 0; i+2 < rendObj.vertexIndexBuffer.numItems; i+=3){
            var a = vertexIndices[i];
            var b = vertexIndices[i+1];
            var c = vertexIndices[i+2];
            
            var p0x = vertices[a*3];
            var p0y = vertices[a*3 + 1];
            var p0z = vertices[a*3 + 2];
            var p1x = vertices[b*3];
            var p1y = vertices[b*3 + 1];
            var p1z = vertices[b*3 + 2];
            var p2x = vertices[c*3];
            var p2y = vertices[c*3 + 1];
            var p2z = vertices[c*3 + 2];
            
            // get 2 vectors from vertices
            var ux = p1x - p0x;
            var uy = p1y - p0y;
            var uz = p1z - p0z;
            var vx = p2x - p0x;
            var vy = p2y - p0y;
            var vz = p2z - p0z;
            
            // cross product
            var nx = uy*vz - uz*vy;
            var ny = uz*vx - ux*vz;
            var nz = ux*vy - uy*vx;
            
            // shader will normalise this after interpolation so no need to it here
            
            // the normal is the same for all 3 points of a triangle
            vertexNormals[a*3]     = vertexNormals[b*3]     = vertexNormals[c*3]     = nx;
            vertexNormals[a*3 + 1] = vertexNormals[b*3 + 1] = vertexNormals[c*3 + 1] = ny;
            vertexNormals[a*3 + 2] = vertexNormals[b*3 + 2] = vertexNormals[c*3 + 2] = nz;
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        rendObj.vertexNormalBuffer.itemSize = rendObj.vertexPositionBuffer.itemSize;
        rendObj.vertexNormalBuffer.numItems = rendObj.vertexPositionBuffer.numItems;
    }

    // Loads geometry for a hex tile into an object
    function makeHex(rendObj) {
        var magicFactor = 1.15;
        var tileThickness = 0.1;
        
        gl.bindBuffer(gl.ARRAY_BUFFER, rendObj.vertexPositionBuffer);
        vertices = [
            //front face
             0.5,  0.866025, tileThickness,
            -0.5,  0.866025, tileThickness,
             1.0,  0.0,      tileThickness,
            -1.0,  0.0,      tileThickness,
             0.5, -0.866025, tileThickness,
            -0.5, -0.866025, tileThickness,
            
            //back face
             0.5,  0.866025, -tileThickness,
            -0.5,  0.866025, -tileThickness,
             1.0,  0.0,      -tileThickness,
            -1.0,  0.0,      -tileThickness,
             0.5, -0.866025, -tileThickness,
            -0.5, -0.866025, -tileThickness,
            
            //front side 1 face
             0.5,  0.866025, tileThickness,
            -0.5,  0.866025, tileThickness,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            
            //front side 2 face
            -0.5,  0.866025, tileThickness,
            -1.0,  0.0,      tileThickness,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //front side 3 face
            -1.0,  0.0,      tileThickness,
            -0.5, -0.866025, tileThickness,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //front side 4 face
            -0.5, -0.866025, tileThickness,
             0.5, -0.866025, tileThickness,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //front side 5 face
             0.5, -0.866025, tileThickness,
             1.0,  0.0,      tileThickness,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //front side 6 face
             1.0,  0.0,      tileThickness,
             0.5,  0.866025, tileThickness,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
            
            //back side 1 face
             0.5,  0.866025, -tileThickness,
            -0.5,  0.866025, -tileThickness,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            
            //back side 2 face
            -0.5,  0.866025, -tileThickness,
            -1.0,  0.0,      -tileThickness,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //back side 3 face
            -1.0,  0.0,      -tileThickness,
            -0.5, -0.866025, -tileThickness,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //back side 4 face
            -0.5, -0.866025, -tileThickness,
             0.5, -0.866025, -tileThickness,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //back side 5 face
             0.5, -0.866025, -tileThickness,
             1.0,  0.0,      -tileThickness,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //back side 6 face
             1.0,  0.0,      -tileThickness,
             0.5,  0.866025, -tileThickness,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        rendObj.vertexPositionBuffer.itemSize = 3;
        rendObj.vertexPositionBuffer.numItems = 60;
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rendObj.vertexIndexBuffer);
        var vertexIndices = [
          // Front face
          0, 1, 2,      1, 3, 2,        2, 3, 4,      3, 5, 4,
          
          // Back face
          8, 7, 6,      8, 9, 7,       10, 9, 8,     10,11, 9,
            
          //front side 1 face
         12,14,13,     13,14,15,
        
          //front side 2 face
         16,18,17,     17,18,19,
        
          //front side 3 face
         20,22,21,     21,22,23,
        
          //front side 4 face
         24,26,25,     25,26,27,
        
          //front side 5 face
         28,30,29,     29,30,31,
        
          //front side 6 face
         32,34,33,     33,34,35,
        
          //back side 1 face
         36,37,38,     37,39,38,
        
          //back side 2 face
         40,41,42,     41,43,42,
        
          //back side 3 face
         44,45,46,     45,47,46,
        
          //back side 4 face
         48,49,50,     49,51,50,
        
          //back side 5 face
         52,53,54,     53,55,54,
        
          //back side 6 face
         56,57,58,     57,59,58,
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
        rendObj.vertexIndexBuffer.itemSize = 1;
        rendObj.vertexIndexBuffer.numItems = 96;
        
        calculateNormals(rendObj, vertices, vertexIndices);
    }

    // Generates hex grid positions
    // size         size of the grid in hexes (0 - 1 hex, 1 - 7 hexes, 2 - 19 hexes etc.)
    // gridScale    distance between centers on the tiles
    function generateHexGrid(size, gridScale){
        var tilePositions = [];
        var i, j;
        for(i = 0; i <= (size-1); i++) {
            var x = (Math.sqrt(3) * i * gridScale) / 2.0;
            for (j = 0; j < (2*size - 1 - i); j++) {
                var y = ((-(2*size - i - 2) * gridScale) / 2.0) + (j * gridScale);
                
                tilePositions.push([x, y, 0.0]);
                if (x != 0) {
                    tilePositions.push([-x, y, 0.0]);
                }
            }
        }
        return tilePositions;
    }

    var renderableObjects = [];
    var timelines = [];

    function initObjects() {
        var gridScale = 2.1;
        var tilePositions = generateHexGrid(30, gridScale);
        
        for (var i in tilePositions) {
            var hexTile = new RenderableObject();
            makeHex(hexTile);
            hexTile.position = tilePositions[i];
            renderableObjects.push(hexTile);
        }
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, pMatrix);
        
        mat4.identity(mvMatrix);
        
        mvPushMatrix();
        
        mat4.translate(mvMatrix, [0.0, 0.0, -80.0]);
        mat4.multiply(mvMatrix, cameraRotationMatrix);
        
        gl.uniform3f(shaderProgram.pointLightingLocationUniform, -1, 2, -1);
        
        gl.uniform3f(shaderProgram.ambientLightingColorUniform, 0.2, 0.2, 0.2);
        gl.uniform3f(shaderProgram.pointLightingDiffuseColorUniform, 0.8, 0.8, 0.8);
        gl.uniform3f(shaderProgram.pointLightingSpecularColorUniform, 0.8, 0.8, 0.8);
        
        for (var i in renderableObjects) {
            renderableObjects[i].draw();
        }
        
        mvPopMatrix();
    }

    // Defines a radius around (0,0,0) within which tiles will be shown.
    var showTilesRadius = 0;
    var showTilesSpeed = 2.0; // per second

    // This function updates time-based things (like animations)
    var lastTime = 0;
    function frameMove() {
        var currentTime = new Date().getTime();
        if (lastTime == 0) {
            lastTime = currentTime;
            return;
        }
        
        var elapsedTime = currentTime - lastTime;
        lastTime = currentTime;
        
        // Tiles start hidden, this code with start displaying them in a growing circle.
        showTilesRadius += (showTilesSpeed * elapsedTime) / 1000;
        for (var i in renderableObjects) {
            if (renderableObjects[i].show == false) {
                var position = renderableObjects[i].position;
                // If position is within the sphere.
                if (Math.pow(position[0], 2) + Math.pow(position[1], 2) + Math.pow(position[2], 2) < Math.pow(showTilesRadius, 2)) {
                    renderableObjects[i].show = true;
                    
                    timelines.push(new InterpolationTimeline(function (value) {this.colour = value}.bind(renderableObjects[i]), [0.0, 0.0, 0.0], [1.0, 1.0, 1.0], 3000));
                    timelines[timelines.length-1].active = true;
                }
            }
        }
        
        // Update timelines
        for (var i in timelines) {
            timelines[i].frameMove(elapsedTime);
        }
    }

    function tick() {
        requestAnimFrame(tick);
        frameMove();
        drawScene();
    }

    function webGLStart() {
        var canvas = document.getElementById("tessellator");
        initGL(canvas);
        initShaders();
        initObjects();
        
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        
        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
        
        lastTime = 0;
        tick();
    }

</script>


</head>


<body onload="webGLStart();">
    <canvas id="tessellator" style="border: none;" width="800" height="800"></canvas>
    <br>
    Rotate the camera by dragging it with the mouse. 
</body>

</html>