<html>

<head>
<title>Tessellator</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

    uniform vec3 uMaterialAmbientColor;
    uniform vec3 uMaterialDiffuseColor;
    uniform vec3 uMaterialSpecularColor;
    uniform float uMaterialShininess;

    uniform vec3 uAmbientLightingColor;

    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingDiffuseColor;
    uniform vec3 uPointLightingSpecularColor;

    uniform sampler2D uSampler;


    void main(void) {
        vec3 ambientLightWeighting = uAmbientLightingColor;
        
        vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
        vec3 normal = normalize(vTransformedNormal);
        
        vec3 eyeDirection = normalize(-vPosition.xyz);
        vec3 reflectionDirection = reflect(-lightDirection, normal);
        
        float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
        vec3 specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;
        
        float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);
        vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;
        
        float alpha = 1.0;
        gl_FragColor = vec4(
            uMaterialAmbientColor * ambientLightWeighting
            + uMaterialDiffuseColor * diffuseLightWeighting
            + uMaterialSpecularColor * specularLightWeighting,
            alpha
        );
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;
    
    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>


<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
            
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
    
    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }
        
        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }
        
        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }
        
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        
        return shader;
    }

    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");
        
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        gl.useProgram(shaderProgram);
        
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
        
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        
        shaderProgram.materialAmbientColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialAmbientColor");
        shaderProgram.materialDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialDiffuseColor");
        shaderProgram.materialSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialSpecularColor");
        shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
        shaderProgram.ambientLightingColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientLightingColor");
        shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
        shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
        shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
    }

    // Matrix helper code
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        
        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }
    // End matrix helper code

    // Code that handles camera rotation via mouse drag.
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;
    var cameraRotationMatrix = mat4.create();
    mat4.identity(cameraRotationMatrix);

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
        mouseDown = false;
        mat4.identity(cameraRotationMatrix);
    }

    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;
        
        var deltaX = newX - lastMouseX
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, deltaX / 200, [0, 1, 0]);
        
        var deltaY = newY - lastMouseY;
        mat4.rotate(newRotationMatrix, deltaY / 200, [1, 0, 0]);
        
        mat4.multiply(newRotationMatrix, cameraRotationMatrix, cameraRotationMatrix);
        
        lastMouseX = newX
        lastMouseY = newY;
    }
    // End camera rotation code

    // Enums
    var GRID_TYPES = {
        HEX     : 1,
        PENROSE : 2,
    };
    
    var TILE_TYPES = {
        HEX           : 1,
        PENROSE_THIN  : 2,
        PENROSE_THICK : 3,
    };

    // Globals
    var renderableObjects = [];
    var timelines = [];
    var showTilesRadius = 0; // Defines a radius around (0,0,0) within which tiles will be shown.
    
    var showTilesSpeed = 2.0; // per second
    
    var gridType = GRID_TYPES.HEX;
    var cameraDistance = -80.0;
    var gridSize = 30;
    var gridScale = 1.05;
    var tileColour = [1.0, 1.0, 1.0];
    var animDuration = 3.0;
    var useCenterAnim = false;
    var customRotationPoint = [0.0, 0.0, 0.0];

    // Pulls the values from the html form and updates globals accordingly, this one is called every frame.
    function handleUserInputDynamic() {
        showTilesSpeed = parseFloat(document.getElementById("gridExpansionRate").value);
    }

    // Pulls the values from the html form and updates globals accordingly, this one is called on reset.
    function handleUserInputOnReset() {
        var radios = document.getElementsByName('gridType');
        for (var i = 0, length = radios.length; i < length; i++)
        {
            if (radios[i].checked)
            {
                if(radios[i].value == "hex") {
                    gridType = GRID_TYPES.HEX;
                } else if(radios[i].value == "penrose") {
                    gridType = GRID_TYPES.PENROSE;
                }
                break;
            }
        }
        
        cameraDistance = parseFloat(document.getElementById("cameraDistance").value);
        
        gridSize = parseInt(document.getElementById("gridSize").value);
        
        gridScale = parseFloat(document.getElementById("gridScale").value);
        
        tileColour = [
            parseFloat(document.getElementById("tileColourR").value),
            parseFloat(document.getElementById("tileColourG").value),
            parseFloat(document.getElementById("tileColourB").value)
        ];
        
        animDuration = parseFloat(document.getElementById("animDuration").value);
        
        radios = document.getElementsByName('animationStyle');
        for (var i = 0, length = radios.length; i < length; i++)
        {
            if (radios[i].checked)
            {
                if(radios[i].value == "center") {
                    useCenterAnim = true;
                } else if(radios[i].value == "edge") {
                    useCenterAnim = false;
                    customRotationPoint = [0.0, 0.0, 10.0];
                } else if(radios[i].value == "custom") {
                    useCenterAnim = false;
                    customRotationPoint = [
                        parseFloat(document.getElementById("animationStyleCustomX").value),
                        parseFloat(document.getElementById("animationStyleCustomY").value),
                        parseFloat(document.getElementById("animationStyleCustomZ").value)
                    ];
                }
                break;
            }
        }
    }

    // Basic object in a scene.
    function RenderableObject() {
        this.vertexPositionBuffer = gl.createBuffer();
        this.vertexNormalBuffer = gl.createBuffer();
        this.vertexIndexBuffer = gl.createBuffer();
        
        // TODO: This kinda breaks the whole "generic renderable object" thing, oh well maybe fix later.
        this.tileOrientation = 0.0; // Counter-clockwise rotation around z axis through the center of the object.
        
        this.colour = [1.0, 1.0, 1.0];
        this.position = [0.0, 0.0, 0.0];
        this.rotationAngle = 0.0; // In radians
        this.rotationAxis = [0.0, 0.0, 0.0];
        this.rotationPoint = [0.0, 0.0, 0.0]; // Point around which the object will be rotated, the point is relative to the position of the object.
//      this.scale = 1.0;
        
        this.show = false;
    }
    
    // Draw function
    RenderableObject.prototype.draw = function () {
        if (!this.show) {
            return;
        }
        
        mvPushMatrix();
        
        mat4.translate(mvMatrix, this.position);
        
        var opposite = this.rotationPoint.map(x => x*(-1.0));
        mat4.translate(mvMatrix, opposite);
        mat4.rotate(mvMatrix, this.rotationAngle, this.rotationAxis);
        mat4.translate(mvMatrix, this.rotationPoint);
        
        mat4.rotateZ(mvMatrix, this.tileOrientation);
        
        gl.uniform3f(shaderProgram.materialAmbientColorUniform, this.colour[0], this.colour[1], this.colour[2]);
        gl.uniform3f(shaderProgram.materialDiffuseColorUniform, this.colour[0], this.colour[1], this.colour[2]);
        gl.uniform3f(shaderProgram.materialSpecularColorUniform, this.colour[0], this.colour[1], this.colour[2]);
        gl.uniform1f(shaderProgram.materialShininessUniform, 5);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, this.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, this.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        
        mvPopMatrix();
    };


    // An object that interpolates a value over time and sets it via a provided function.
    // setterCallback   The function that will be called with interpolated value as parameter.
    // startValue       Value to be set at the start of the timeline
    // endValue         Value to be set at the end of the timeline
    // duration         Amount of time (in milliseconds) in will take to go from startValue to endValue
    function InterpolationTimeline(setterCallback, startValue, endValue, duration) {
        if (duration == 0) {
            duration = 1; // hacky but we don't want to divide by zero
        }
        
        this.setterCallback = setterCallback;
        this.startValue = startValue;
        this.endValue = endValue;
        this.duration = duration;
        
        this.elapsedTime = 0;
        this.active = false;
    }
    
    InterpolationTimeline.prototype.frameMove = function (deltaTime) {
        if (this.active == false) {
            return;
        }
        
        if (!Array.isArray(this.startValue) && !Array.isArray(this.endValue)) {
            this.setterCallback((this.startValue * (1 - (this.elapsedTime / this.duration))) + (this.endValue * (this.elapsedTime / this.duration)));
        } else if (Array.isArray(this.startValue) && Array.isArray(this.endValue) && this.startValue.length == this.endValue.length) {
            var finalValue = [];
            var i;
            for(i = 0; i < this.startValue.length; i++) {
                finalValue[i] = (this.startValue[i] * (1 - (this.elapsedTime / this.duration))) + (this.endValue[i] * (this.elapsedTime / this.duration));
            }
            this.setterCallback(finalValue);
        }
        
        if (this.elapsedTime >= this.duration) {
            this.active = false;
        }
        this.elapsedTime += deltaTime;
        if (this.elapsedTime > this.duration) {
            this.elapsedTime = this.duration;
        }
    }


    // Calculates perpendicular vertex normals from geometry definition, triangle vertices need to be
    // defines in counter-clockwise order from the direction into which normal will point.
    function calculateNormals(rendObj, vertices, vertexIndices)
    {
        rendObj.vertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, rendObj.vertexNormalBuffer);
        var vertexNormals = new Float32Array(rendObj.vertexPositionBuffer.numItems * rendObj.vertexPositionBuffer.itemSize);
        for (var i = 0; i+2 < rendObj.vertexIndexBuffer.numItems; i+=3){
            var a = vertexIndices[i];
            var b = vertexIndices[i+1];
            var c = vertexIndices[i+2];
            
            var p0x = vertices[a*3];
            var p0y = vertices[a*3 + 1];
            var p0z = vertices[a*3 + 2];
            var p1x = vertices[b*3];
            var p1y = vertices[b*3 + 1];
            var p1z = vertices[b*3 + 2];
            var p2x = vertices[c*3];
            var p2y = vertices[c*3 + 1];
            var p2z = vertices[c*3 + 2];
            
            // get 2 vectors from vertices
            var ux = p1x - p0x;
            var uy = p1y - p0y;
            var uz = p1z - p0z;
            var vx = p2x - p0x;
            var vy = p2y - p0y;
            var vz = p2z - p0z;
            
            // cross product
            var nx = uy*vz - uz*vy;
            var ny = uz*vx - ux*vz;
            var nz = ux*vy - uy*vx;
            
            // shader will normalise this after interpolation so no need to it here
            
            // the normal is the same for all 3 points of a triangle
            vertexNormals[a*3]     = vertexNormals[b*3]     = vertexNormals[c*3]     = nx;
            vertexNormals[a*3 + 1] = vertexNormals[b*3 + 1] = vertexNormals[c*3 + 1] = ny;
            vertexNormals[a*3 + 2] = vertexNormals[b*3 + 2] = vertexNormals[c*3 + 2] = nz;
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        rendObj.vertexNormalBuffer.itemSize = rendObj.vertexPositionBuffer.itemSize;
        rendObj.vertexNormalBuffer.numItems = rendObj.vertexPositionBuffer.numItems;
    }

    var magicFactor = 1.15; // The factor by which the middle of the tile is bigger then the faces.
    var tileThickness = 0.1;
    // Loads geometry for a hex tile into an object
    function makeHex(rendObj) {        
        gl.bindBuffer(gl.ARRAY_BUFFER, rendObj.vertexPositionBuffer);
        vertices = [
            //front face
             0.5,  0.866025, tileThickness,
            -0.5,  0.866025, tileThickness,
             1.0,  0.0,      tileThickness,
            -1.0,  0.0,      tileThickness,
             0.5, -0.866025, tileThickness,
            -0.5, -0.866025, tileThickness,
            
            //back face
             0.5,  0.866025, -tileThickness,
            -0.5,  0.866025, -tileThickness,
             1.0,  0.0,      -tileThickness,
            -1.0,  0.0,      -tileThickness,
             0.5, -0.866025, -tileThickness,
            -0.5, -0.866025, -tileThickness,
            
            //front side 1 face
             0.5,  0.866025, tileThickness,
            -0.5,  0.866025, tileThickness,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            
            //front side 2 face
            -0.5,  0.866025, tileThickness,
            -1.0,  0.0,      tileThickness,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //front side 3 face
            -1.0,  0.0,      tileThickness,
            -0.5, -0.866025, tileThickness,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //front side 4 face
            -0.5, -0.866025, tileThickness,
             0.5, -0.866025, tileThickness,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //front side 5 face
             0.5, -0.866025, tileThickness,
             1.0,  0.0,      tileThickness,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //front side 6 face
             1.0,  0.0,      tileThickness,
             0.5,  0.866025, tileThickness,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
            
            //back side 1 face
             0.5,  0.866025, -tileThickness,
            -0.5,  0.866025, -tileThickness,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            
            //back side 2 face
            -0.5,  0.866025, -tileThickness,
            -1.0,  0.0,      -tileThickness,
            -0.5*magicFactor,  0.866025*magicFactor, 0.0,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //back side 3 face
            -1.0,  0.0,      -tileThickness,
            -0.5, -0.866025, -tileThickness,
            -1.0*magicFactor,  0.0*magicFactor,      0.0,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //back side 4 face
            -0.5, -0.866025, -tileThickness,
             0.5, -0.866025, -tileThickness,
            -0.5*magicFactor, -0.866025*magicFactor, 0.0,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
            
            //back side 5 face
             0.5, -0.866025, -tileThickness,
             1.0,  0.0,      -tileThickness,
             0.5*magicFactor, -0.866025*magicFactor, 0.0,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
            
            //back side 6 face
             1.0,  0.0,      -tileThickness,
             0.5,  0.866025, -tileThickness,
             1.0*magicFactor,  0.0*magicFactor,      0.0,
             0.5*magicFactor,  0.866025*magicFactor, 0.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        rendObj.vertexPositionBuffer.itemSize = 3;
        rendObj.vertexPositionBuffer.numItems = 60;
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rendObj.vertexIndexBuffer);
        var vertexIndices = [
          // Front face
          0, 1, 2,      1, 3, 2,        2, 3, 4,      3, 5, 4,
          
          // Back face
          8, 7, 6,      8, 9, 7,       10, 9, 8,     10,11, 9,
            
          //front side 1 face
         12,14,13,     13,14,15,
        
          //front side 2 face
         16,18,17,     17,18,19,
        
          //front side 3 face
         20,22,21,     21,22,23,
        
          //front side 4 face
         24,26,25,     25,26,27,
        
          //front side 5 face
         28,30,29,     29,30,31,
        
          //front side 6 face
         32,34,33,     33,34,35,
        
          //back side 1 face
         36,37,38,     37,39,38,
        
          //back side 2 face
         40,41,42,     41,43,42,
        
          //back side 3 face
         44,45,46,     45,47,46,
        
          //back side 4 face
         48,49,50,     49,51,50,
        
          //back side 5 face
         52,53,54,     53,55,54,
        
          //back side 6 face
         56,57,58,     57,59,58,
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
        rendObj.vertexIndexBuffer.itemSize = 1;
        rendObj.vertexIndexBuffer.numItems = 96;
        
        calculateNormals(rendObj, vertices, vertexIndices);
    }

    // Loads geometry for a rhomb tile of specified width and height into an object
    function makeRhomdTile(rendObj, width, heigth) {
        var halfWidth = width / 2;
        var halfHeigth = heigth / 2;
        
        gl.bindBuffer(gl.ARRAY_BUFFER, rendObj.vertexPositionBuffer);
        vertices = [
            //front face
             0.0,           halfHeigth,     tileThickness,
             halfWidth,     0.0,            tileThickness,
             -halfWidth,    0.0,            tileThickness,
             0.0,           -halfHeigth,    tileThickness,
            
            //back face
             0.0,           halfHeigth,     -tileThickness,
             halfWidth,     0.0,            -tileThickness,
             -halfWidth,    0.0,            -tileThickness,
             0.0,           -halfHeigth,    -tileThickness,
            
            //front side 1 face
             0.0,                   halfHeigth,                 tileThickness,
             halfWidth,             0.0,                        tileThickness,
             0.0*magicFactor,       halfHeigth*magicFactor,     0.0,
             halfWidth*magicFactor, 0.0*magicFactor,            0.0,
            
            //front side 2 face
             halfWidth,             0.0,                        tileThickness,
             0.0,                   -halfHeigth,                tileThickness,
             halfWidth*magicFactor, 0.0*magicFactor,            0.0,
             0.0*magicFactor,       -halfHeigth*magicFactor,    0.0,
            
            //front side 3 face
             0.0,                   -halfHeigth,                tileThickness,
            -halfWidth,             0.0,                        tileThickness,
             0.0*magicFactor,       -halfHeigth*magicFactor,    0.0,
            -halfWidth*magicFactor, 0.0*magicFactor,            0.0,
            
            //front side 4 face
            -halfWidth,             0.0,                        tileThickness,
             0.0,                   halfHeigth,                 tileThickness,
            -halfWidth*magicFactor, 0.0*magicFactor,            0.0,
             0.0*magicFactor,       halfHeigth*magicFactor,     0.0,
            
            //back side 1 face
             0.0,                   halfHeigth,                 -tileThickness,
             halfWidth,             0.0,                        -tileThickness,
             0.0*magicFactor,       halfHeigth*magicFactor,     0.0,
             halfWidth*magicFactor, 0.0*magicFactor,            0.0,
            
            //back side 2 face
             halfWidth,             0.0,                        -tileThickness,
             0.0,                   -halfHeigth,                -tileThickness,
             halfWidth*magicFactor, 0.0*magicFactor,            0.0,
             0.0*magicFactor,       -halfHeigth*magicFactor,    0.0,
            
            //back side 3 face
             0.0,                   -halfHeigth,                -tileThickness,
            -halfWidth,             0.0,                        -tileThickness,
             0.0*magicFactor,       -halfHeigth*magicFactor,    0.0,
            -halfWidth*magicFactor, 0.0*magicFactor,            0.0,
            
            //back side 4 face
            -halfWidth,             0.0,                        -tileThickness,
             0.0,                   halfHeigth,                 -tileThickness,
            -halfWidth*magicFactor, 0.0*magicFactor,            0.0,
             0.0*magicFactor,       halfHeigth*magicFactor,     0.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        rendObj.vertexPositionBuffer.itemSize = 3;
        rendObj.vertexPositionBuffer.numItems = 40;
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rendObj.vertexIndexBuffer);
        var vertexIndices = [
              // Front face
              0, 2, 1,      1, 2, 3,
              
              // Back face
              4, 5, 6,      5, 7, 6,
                
              //front side 1 face
              8, 9,10,     10, 9,11,
            
              //front side 2 face
             12,13,14,     14,13,15,
            
              //front side 3 face
             16,17,18,     18,17,19,
            
              //front side 4 face
             20,21,22,     22,21,23,
            
              //back side 1 face
             24,26,25,     26,27,25,
            
              //back side 2 face
             28,30,29,     30,31,29,
            
              //back side 3 face
             32,34,33,     34,35,33,
            
              //back side 4 face
             36,38,37,     38,39,37,
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
        rendObj.vertexIndexBuffer.itemSize = 1;
        rendObj.vertexIndexBuffer.numItems = 60;
        
        calculateNormals(rendObj, vertices, vertexIndices);
    }
    
    // Loads geometry for a Penrose P3 thin rhomb tile into an object
    function makePenroseThinRhomd(rendObj) {
        makeRhomdTile(rendObj, 0.650, 2.0);
    }
    
    // Loads geometry for a Penrose P3 thick rhomb tile into an object
    function makePenroseThickRhomd(rendObj) {
        makeRhomdTile(rendObj, 1.236, 1.7);
    }

    // Generates hex grid positions
    // size         size of the grid in hexes (0 - 1 hex, 1 - 7 hexes, 2 - 19 hexes etc.)
    // gridScale    distance between centers on the tiles
    function generateHexGrid(size, gridScale){
        var tilePositions = [];
        var i, j;
        for(i = 0; i <= (size-1); i++) {
            var x = Math.sqrt(3) * i * gridScale;
            for (j = 0; j < (2*size - 1 - i); j++) {
                var y = (-(2*size - i - 2) * gridScale) + (j * 2 * gridScale);
                
                tilePositions.push([x, y, 0.0]);
                if (x != 0) {
                    tilePositions.push([-x, y, 0.0]);
                }
            }
        }
        return tilePositions;
    }

    // Generates Penrose grid specifications (tile type, position, orientation)
    // gridScale    distance between centers on the tiles
    function TileSpecs(type, position, orientation) {
        this.type = type;
        this.position = position;
        this.orientation = orientation;
    }
    function generatePenroseGrid(gridScale){
        //TODO: actually generate positions (aka the easy part)
        var tileSpecsList = [
            new TileSpecs(TILE_TYPES.PENROSE_THICK, [gridScale*0,      gridScale*1,      0], 0),
            new TileSpecs(TILE_TYPES.PENROSE_THICK, [gridScale*0.951,  gridScale*0.309,  0], 5.026548),
            new TileSpecs(TILE_TYPES.PENROSE_THICK, [gridScale*0.588,  gridScale*-0.809, 0], 3.769911),
            new TileSpecs(TILE_TYPES.PENROSE_THICK, [gridScale*-0.588, gridScale*-0.809, 0], 2.513274),
            new TileSpecs(TILE_TYPES.PENROSE_THICK, [gridScale*-0.951, gridScale*0.309,  0], 1.256637),
            
            new TileSpecs(TILE_TYPES.PENROSE_THIN,  [gridScale*0.95176,  gridScale*1.30941,  0], 5.6548665 + 1.570796),
            new TileSpecs(TILE_TYPES.PENROSE_THIN,  [gridScale*1.54000,  gridScale*-0.50000, 0], 4.3982295 + 1.570796),
            new TileSpecs(TILE_TYPES.PENROSE_THIN,  [gridScale*0,        gridScale*-1.61882, 0], 3.1415925 + 1.570796),
            new TileSpecs(TILE_TYPES.PENROSE_THIN,  [gridScale*-1.54000, gridScale*-0.50000, 0], 1.8849555 + 1.570796),
            new TileSpecs(TILE_TYPES.PENROSE_THIN,  [gridScale*-0.95176, gridScale*1.30941,  0], 0.6283185 + 1.570796),
        ];
        return tileSpecsList;
    }

    function initObjects() {
        if (gridType == GRID_TYPES.HEX)
        {
            var tilePositions = generateHexGrid(gridSize, gridScale);
            for (var i in tilePositions) {
                var tile = new RenderableObject();
                makeHex(tile);
                tile.position = tilePositions[i];
                renderableObjects.push(tile);
            }
        }
        else if (gridType == GRID_TYPES.PENROSE) {
            var tileSpecs = generatePenroseGrid(gridScale);
            for (var i in tileSpecs) {
                var tile = new RenderableObject();
                if (tileSpecs[i].type == TILE_TYPES.PENROSE_THIN) {
                    makePenroseThinRhomd(tile);
                } else if (tileSpecs[i].type == TILE_TYPES.PENROSE_THICK) {
                    makePenroseThickRhomd(tile);
                }
                tile.position = tileSpecs[i].position;
                tile.tileOrientation = tileSpecs[i].orientation;
                renderableObjects.push(tile);
            }
        }
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, pMatrix);
        
        mat4.identity(mvMatrix);
        
        mvPushMatrix();
        
        mat4.translate(mvMatrix, [0.0, 0.0, cameraDistance]);
        mat4.multiply(mvMatrix, cameraRotationMatrix);
        
        gl.uniform3f(shaderProgram.pointLightingLocationUniform, -1, 2, -1);
        
        gl.uniform3f(shaderProgram.ambientLightingColorUniform, 0.2, 0.2, 0.2);
        gl.uniform3f(shaderProgram.pointLightingDiffuseColorUniform, 0.8, 0.8, 0.8);
        gl.uniform3f(shaderProgram.pointLightingSpecularColorUniform, 0.8, 0.8, 0.8);
        
        for (var i in renderableObjects) {
            renderableObjects[i].draw();
        }
        
        mvPopMatrix();
    }

    // This function updates time-based things (like animations)
    var lastTime = 0;
    function frameMove() {
        var currentTime = new Date().getTime();
        if (lastTime == 0) {
            lastTime = currentTime;
            return;
        }
        
        var elapsedTime = currentTime - lastTime;
        lastTime = currentTime;
        
        // Tiles start hidden, this code with start displaying them in a growing circle.
        showTilesRadius += (showTilesSpeed * elapsedTime) / 1000;
        for (var i in renderableObjects) {
            if (renderableObjects[i].show == false) {
                var position = renderableObjects[i].position;
                // If position is within the sphere.
                if (Math.pow(position[0], 2) + Math.pow(position[1], 2) + Math.pow(position[2], 2) < Math.pow(showTilesRadius, 2)) {
                    renderableObjects[i].show = true;
                    
                    // Setup a timeline that will gradually shift the tile from black to white.
                    timelines.push(new InterpolationTimeline(function (value) {this.colour = value}.bind(renderableObjects[i]), [0.0, 0.0, 0.0], tileColour, animDuration*1000));
                    timelines[timelines.length-1].active = true;
                    
                    // Setup a timeline that will move tiles into place (by rotating them around a point behind them).
                    if (useCenterAnim == true) {
                        renderableObjects[i].rotationPoint = [renderableObjects[i].position[0]*0.5, renderableObjects[i].position[1]*0.5, 10];
                    } else {
                        renderableObjects[i].rotationPoint = customRotationPoint;
                    }
                    // If you treat the position as a vector we want the rotation axis to be perpendicular to it in the plate of the mosaic.
                    renderableObjects[i].rotationAxis = [renderableObjects[i].position[1]*-1, renderableObjects[i].position[0], 0];
                    timelines.push(new InterpolationTimeline(function (value) {this.rotationAngle = value}.bind(renderableObjects[i]), Math.PI, 0.0, animDuration*1000));
                    timelines[timelines.length-1].active = true;
                }
            }
        }
        
        // Update timelines
        for (var i in timelines) {
            timelines[i].frameMove(elapsedTime);
        }
    }

    function tick() {
        requestAnimFrame(tick);
        
        handleUserInputDynamic();
        frameMove();
        drawScene();
    }

    function reset() {
        renderableObjects = [];
        timelines = [];
        showTilesRadius = 0;
        
        handleUserInputOnReset();
        
        initShaders();
        initObjects();
    }

    function webGLStart() {
        var canvas = document.getElementById("tessellator");
        initGL(canvas);
        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
        
        reset();
        
        lastTime = 0;
        tick();
    }

</script>


</head>


<body onload="webGLStart();">
  <table>
    <tr>
      <td>
        <canvas id="tessellator" style="border: none;" width="800" height="800"></canvas>
        <br>
        Rotate the camera by dragging it with the mouse.
      </td>
      <td>
        <form>
          Choose grid type:
          <input type="radio" name="gridType" value="hex" checked>Hexagonal
          <input type="radio" name="gridType" value="penrose">Penrose<br>
          
          Camera distance:
          <input type="text" id="cameraDistance" value="-80.0" size="5"><br>
          
          Grid size:
          <input type="text" id="gridSize" value="30" size="4"><br>
          
          Distance between tiles:
          <input type="text" id="gridScale" value="1.05" size="4"><br>
          
          Grid expansion rate (per sec):
          <input type="text" id="gridExpansionRate" value="2.0" size="4"><br>
          
          Tile colour:
          <input type="text" id="tileColourR" value="1.0" size="3">
          <input type="text" id="tileColourG" value="1.0" size="3">
          <input type="text" id="tileColourB" value="1.0" size="3"> <br>
          
          Animation duration (sec):
          <input type="text" id="animDuration" value="3.0" size="4"><br>
          
          Choose animation style:<br>
          <input type="radio" name="animationStyle" value="center" checked>Tiles start from the center<br>
          <input type="radio" name="animationStyle" value="edge">Tiles start from the edge<br>
          <input type="radio" name="animationStyle" value="custom">Specify rotation point (relative to the tile)
          <input type="text" id="animationStyleCustomX" value="0.0" size="5">
          <input type="text" id="animationStyleCustomY" value="0.0" size="5">
          <input type="text" id="animationStyleCustomZ" value="10.0" size="5"> <br>
        </form>
        <button type="button" onclick="reset()">Reset Animation</button>
      </td>
    </tr>
  </table>
</body>

</html>